# 폰노이만 아키텍처

## 중앙처리장치 (CPU)의 역할

- 0과 1로 구성된 명령어를 하나씩 수행하는 장치

## Disk만 있을 경우

1. CPU가 동작할 명령어들을 Disk에 저장해둔다
2. Disk에서 명령어를 하나씩 CPU에 전달한다
3. CPU가 명령어를 수행한다

- CPU의 효율이 너무 떨어진다
  - CPU에 비해 Disk가 너무 느리다

## 폰노이만의 아이디어

> 1941년 프로그램 내장방식을 통해 메모리가 필요하다고 주장

## 메모리를 추가할 경우

- 빠른 성능
- 저장장치처럼 저장하는 기능을 갖지만, 전원을 끄면 모두 소멸되는 장치
- 명령어들을 대신 전달해주는 역할을 한다

1. Load 작업
   - 저장장치에 저장된 0과 1 장치가 메모리에 한꺼번에 복사된다
   - 프로그램 전체를 모두 불러와야하기 때문에 시간이 걸린다
   - 이를 흔히 로딩 (Loading)이라고 부른다
2. Disk 대신 메모리가 명령어들을 하나씩 CPU에 전달한다
   - CPU와 메모리 사이에 데이터를 주고 받는다
   - 여전히 CPU 보다 느리다
   - HDD에 비하면 엄청 빠르다

---

# D램과 S램

## D램만 활용할 경우

- Load 작업은 느리다
- 메모리가 명령어를 전달하는 동안 속도가 더 빠른 CPU는 기다리는 시간이 발생한다

## S램을 추가할 경우

- CPU 안에, 더 빠른 메모리를 내장한다
- 저장공간은 작지만, 기존의 메모리보다 더 빠른 성능을 내는 메모리

1. D램에서 S램으로 여러줄의 명령어를 한꺼번에 전달한다
2. D램 대신 S램이 명령어들을 하나씩 CPU에 전달한다
   - 기존보다 더 빠르게 한줄씩, 명령어를 수행한다

- 이 S램을 Cache 메모리라고 한다
  - Cache 메모리에 Hit/Miss 전략을 통해, 효율성을 더 높이는 방법도 존재한다

---

# 프로그램과 프로세스

## 프로세스 개념정리

|용어|개념|
|:---|:---|
|프로그램|CPU의 2진수 명령어들의 집합  프로그램을 실행하면 메모리에 적재된다 (로딩)|
|프로세서|프로그램을 실행하는 칩셋 (HW)|
|프로세스|실행된 프로그램|
|스레드|프로세스 내 작업을 수행하는 단위  프로세스에는 기본적으로 하나의 스레드가 동작한다|

## 멀티태스킹 개념정리

- 여러개의 프로세스가 동작하는 것

|용어|개념|
|:---|:---|
|멀티 프로세스|여러 CPU로 여러 프로세스가 동작하는 것|
|멀티 스레드|프로세스 내 여러 개의 스레드가 동시에 동작하는 상황|

# 메모리 구조

## 메모리의 역할

- 0과 1로 된 CPU 명령어를 저장하는 역할
- 변수가 만들어지는 역할
- 프로세스는 메모리 공간을 나누어서 활용한다
  - 변수값들을 서로 공유할 수 없다
  - IPC를 이용하면 가능하다
- 각 프로세스는 세부적인 공간을 가진다

## 프로세스의 공간 구성

|공간|역할|
|:---|:---|
|text|코드 영역|
|data|초기화된 전역변수, 하드코딩 데이터|
|bss|초기화 안된 전역변수, 초기값이 없음|
|heap|지역변수|
|stack|malloc으로 만든 변수들|

---

# 동시 작업이 필요한 경우

## 멀티 프로세스 (Multi Process)

- CPU는 한번에 한가지 동작만 수행한다
- 여러 프로세스를 동시에 수행하기 위해 매우 빠른 속도로 하나씩 돌아가면서 수행한다
- 이런 작업을 커널이 지원해야 한다

> **프로세스끼리 독립된 메모리 공간을 갖는다**
> IPC를 이용하면 변수값들을 서로 공유할 수 있다

### Context Switching

- 하나의 프로세스가 CPU를 사용중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 적재하는 것

## 멀티 스레드 (Multi Thread)

- 한 프로세스 안에서 캐릭터들이 동시에 움직이도록 코딩하는 것
- 운영체제가 API로 지원해 주어야만 한다
- Thread를 위한 POSIX API가 존재한다

### 임베디드 S/W 개발의 경우

- Firmware 개발 Level로는 어렵다
- POSIX API가 지원되는 OS를 임베디드 제품에 설치해야 한다
- RTOS 또는 Linux OS를 설치 후 임베디드 개발을 한다

# 스레드 (Thread)

## 보이드 포인터 (void *)

- 모든 타입의 주소를 저장할 수 있는 만능 포인터
- 포인터를 바로 사용할 수 없다

> void 포인터로 저장된 주소는 형변환하여 사용 가능하다

`*([포인터타입] *)p`

``` C
#include <stdio.h>

int main() {
  int x = 0;
  void *p = &x;

  printf("%d", *(int *)p);

  return 0;
}
```

# Thread 시작

## pthread Library

- 두 개 이상의 함수(main)를 동시에 실행시키고 싶을 때 사용한다

1. `pthread.h` 라이브러리를 추가한다
2. 리턴값이 `void *`인 함수를 생성한다
3. `pthread_t` 구조체 변수를 생성한다
4. `pthread_create`를 통해 스레드를 할당한다
5. `pthread_join`를 통해 메모리 해제(정리작업)을 한다
   - `pthread_join([thread id], [thread 리턴 값])`
6. Build
   - gcc를 통해 Build시에는 `-lpthread` 옵션을 통해 pthread 라이브러리를 Link 해주어야 한다
   - `gcc ./[c파일명] -o ./[실행파일명] -lpthread`

``` C
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

void *abc()
// 리턴값이 void 포인터
// C 언어에서 함수를 받으려면 void *를 사용해야함
{
	while(1) {
		printf("ABC\n");
		sleep(1);
	}

	return 0;
}

void *bts() {
	while(1) {
		printf("BTS\n");
		sleep(1);
	}

	return 0;
}

int main()
{
	pthread_t t1, t2;

	pthread_create(&t1, NULL, abc, NULL);
	pthread_create(&t2, NULL, bts, NULL);
  // 깡통 구조체를 넣으면 스레드의 main 함수가 abc 로 채워져서 나온다
  // `pthread_create([비어있는 구조체], [옵션], [메인함수], [함수의 파라미터])`
  // 값을 여러개 받을 때는 구조체 사용

	pthread_join(t1, NULL);
	pthread_join(t2, NULL);
  // t1 스레드가 끝날 때까지 대기
  // `pthread_join(t1, [리턴값])`

	return 0;
}
```

## Thread 인자 값 넘기기

Thread에 인자 값을 넘길 수 있다
- create시 변수의 주소를 넘기는 방식 사용
- 구조체 변수를 사용하면, 더 많은 값을 넘길 수 있다


---



- Race Condition
  - Thread / Process의 타이밍에 따라 결과 값이 달라질 수 있는 상태
- 임계영역 (Critical Section)
  - Thread / Process가 동시에 접근해서는 안되는 곳
  - HW 장치를 사용하는 곳 / Shared Resource (전역변수 등)