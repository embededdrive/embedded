# 10진수, 2진수, 16진수

## 16진수를 사용하는 이유

- 사람이 알아보기 힘든 2진수를 10진수로 변환하는데 계산이 오래걸린다
- 2진수를 보다 알아보기 쉽게 쓰기 위해 16진수를 사용한다

## 진법변환을 공부하는 이유

- 10진수, 2진수, 16진수를 사용해서 임베디드 개발을 해야하기 때문

# 표기 방법

## 2진수

- `0b[숫자]`

## 16진수

- `0x[숫자]`

## 2진수 10진수 16진수 변환표

|2진수|10진수|16진수|
|:---:|:---:|:---:|
|0b0000|0|0x0|
|0b0001|1|0x1|
|0b0010|2|0x2|
|0b0011|3|0x3|
|0b0100|4|0x4|
|0b0101|5|0x5|
|0b0110|6|0x6|
|0b0111|7|0x7|
|0b1000|8|0x8|
|0b1001|9|0x9|
|0b1010|10|0xA|
|0b1011|11|0xB|
|0b1100|12|0xC|
|0b1101|13|0xD|
|0b1110|14|0xE|
|0b1111|15|0xF|

## MSB, LSB

- 1 Byte는 8bit로 구성되어 있다
- MSB (Most Significant Bit)
  - 비트 단위의 연산에 있어서 그 숫자 값의 크기에 가장 크게 영향을 미치는 유효 숫자
  - ex) 1바이트 인 경우 : 7번 bit
- LSB (Least Significant Bit) 
  - 항상 0번 bit

# 비트연산

## 비트연산을 공부하는 이유

- 임베디드 개발자는 비트연산을 사용해서, 장치를 제어하기 때문

## and 연산 (`&`)

- 값을 추출할 때 사용한다
- 값에 "1"을 적은 곳만 추출한다
- ex) 1001 & 0011 = 0001

## or 연산 (`|`)

- 2진수 덧셈시에 사용된다
- 둘 중 한 곳에 "1"이 있으면 결과는 "1"이다
- ex) 1001 | 0011 = 1011

## Left Shift (`<<`)

- 값을 밀어서 숫자를 추가한다
- ex) 0011 << 1 = 0110

## Right Shift (`>>`)

- 값을 밀어서 숫자를 제거한다
- ex) 0011 >> 1 = 0001

## not (`~`)

- 값이 반대가 된다
- 기준 비트 수에 따라 값이 달라진다
- ex) ~0011 = 1100

``` c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

setbuf(stdout, NULL);
```
